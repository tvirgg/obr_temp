### ./eslint.config.mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;


### ./next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


### ./next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


### ./p.py
#!/usr/bin/env python3
"""
Экспортирует *только* исходный код проекта в один TXT.

  • игнорирует node_modules, .next, public, .git и пр.;
  • записывает содержимое файлов с «кодовыми» расширениями;
  • бинарные и большие файлы пропускает.

По необходимости расширяйте / сужайте ALLOWED_EXTS и IGNORED_DIRS.
"""

from __future__ import annotations
import os
import argparse
from pathlib import Path
from typing import Set

# --- что считать «файлом с кодом» -------------------------------------------
ALLOWED_EXTS: Set[str] = {
    ".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs",
    ".py", ".css", ".scss",
    ".json", ".yml", ".yaml",
}

# --- какие каталоги и файлы полностью исключаем -----------------------------
IGNORED_DIRS: Set[str] = {
    ".git", "node_modules", ".next", ".turbo", "dist", "build",
    "coverage", "public", "__tests__", ".storybook", ".vscode",
}

IGNORED_FILE_EXTS: Set[str] = {
    ".png", ".jpg", ".jpeg", ".gif", ".svg", ".ico",
    ".ttf", ".woff", ".woff2", ".mp4", ".webm", ".map",
}

MAX_FILE_SIZE_BYTES = 1_000_000  # >1 МБ считаем неподходящим


# ---------------------------------------------------------------------------
def looks_like_text(path: Path, blocksize: int = 512) -> bool:
    """
    Очень грубый «текст/бинарный» тест: наличие нулевого байта
    в первой порции данных.
    """
    try:
        with path.open("rb") as f:
            return b"\0" not in f.read(blocksize)
    except Exception:
        return False


def is_code_file(path: Path) -> bool:
    """Решаем, нужно ли сохранять этот файл."""
    if path.suffix in IGNORED_FILE_EXTS:
        return False
    if path.suffix.lower() not in ALLOWED_EXTS:
        return False
    if path.stat().st_size > MAX_FILE_SIZE_BYTES:
        return False
    return True


def dump_code_tree(output_file: str, encoding: str = "utf-8") -> None:
    with open(output_file, "w", encoding=encoding) as out:
        for root, dirs, files in os.walk("."):
            # 1) выкидываем лишние каталоги из обхода
            dirs[:] = [d for d in dirs if d not in IGNORED_DIRS]

            for filename in files:
                path = Path(root) / filename
                if not is_code_file(path):
                    continue
                if not looks_like_text(path):
                    # пропускаем binary / minified junk
                    continue

                rel_path = path.relative_to(".")
                out.write(f"### ./{rel_path.as_posix()}\n")
                try:
                    out.write(path.read_text(encoding=encoding, errors="replace"))
                except Exception as exc:
                    out.write(f"[could not read file: {exc}]")
                out.write("\n\n")  # визуальный разделитель


# ---------------------------------------------------------------------------
def main() -> None:
    parser = argparse.ArgumentParser(
        description="Собирает исходники проекта (Next.js / любой JS-стек) в один TXT."
    )
    parser.add_argument(
        "-o",
        "--output",
        default="code.txt",
        help="Имя выходного файла (по умолчанию code.txt)",
    )
    parser.add_argument(
        "--encoding",
        default="utf-8",
        help="Кодировка для чтения файлов (по умолчанию UTF-8)",
    )
    args = parser.parse_args()
    dump_code_tree(args.output, args.encoding)


if __name__ == "__main__":
    main()


### ./package.json
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build --no-lint",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@reduxjs/toolkit": "^2.8.2",
    "axios": "^1.10.0",
    "next": "15.3.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-redux": "^9.2.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.4",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


### ./postcss.config.mjs
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;


### ./tsconfig.json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


### ./src/app/fonts.ts
// app/fonts.ts
import localFont from "next/font/local";

export const doloman = localFont({
  variable: "--font-doloman",       // объявим переменную
  display:  "swap",
  src: [
    { path: "../../public/fonts/DolomanPavljenko.otf", weight: "400", style: "normal" },
    // добавьте Bold/Italic при необходимости
  ],
});


### ./src/app/globals.css
@import "tailwindcss";

/* 
  Комментарии здесь, ВНЕ блока @theme, совершенно безопасны.
*/

/* 1. Объявляем ваши кастомные шрифты */
@font-face {
  font-family: 'Cruinn';
  src: url('/fonts/CruinnLight.ttf') format('truetype');
  font-weight: 300;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Cruinn';
  src: url('/fonts/CruinnMedium.ttf') format('truetype');
  font-weight: 500;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Cruinn';
  src: url('/fonts/CruinnBlack.ttf') format('truetype');
  font-weight: 900;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "Doloman Pavlijenko";  /* ← имя из файла! */
  src: url("/fonts/DolomanPavljenko.otf") format("woff2");
  font-display: swap;
}

@theme {
  --font-sans: var(--font-doloman);      /* теперь font‑sans == Doloman */
  --font-mono: var(--font-geist-mono);   /* ← Geist Mono оставляем */
}
/* 3. Ваши остальные стили */
:root {
  --background: #EBEAE8;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
    font-family: 'Doloman Pavlijenko', sans-serif;
}

### ./src/app/layout.tsx
// src/app/layout.tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { doloman } from "./fonts";              // ⬅ наш локальный
import { ReduxProvider } from "../store/Provider";
import { Header } from "../components/Header";
import "./globals.css";


export const metadata: Metadata = {
  title: "Образно - Дизайн интерьера с ИИ",
  description: "Создавайте уникальные дизайны интерьера с помощью искусственного интеллекта",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="ru"
          className={`${doloman.variable}`}>
      {/* ░░ tailwind preflight уже поставит font‑sans на html/body ░░ */}
      <body className="font-sans antialiased">
        <ReduxProvider>
          <Header />
          <main className="min-h-screen bg-[#EBEAE8]">{children}</main>
        </ReduxProvider>
      </body>
    </html>
  );
}


### ./src/app/page.tsx
import Image from "next/image";

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="list-inside list-decimal text-sm/6 text-center sm:text-left font-[family-name:var(--font-geist-mono)]">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] px-1 py-0.5 rounded font-[family-name:var(--font-geist-mono)] font-semibold">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}


### ./src/app/(auth)/layout.tsx
"use client";
import { useAppSelector } from '@/store/hooks';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

export default function AuthLayout({ children }: { children: React.ReactNode }) {
  const isAuthenticated = useAppSelector((state) => state.auth.isAuthenticated);
  const router = useRouter();

  useEffect(() => {
    if (isAuthenticated) {
      router.push('/dashboard');
    }
  }, [isAuthenticated, router]);

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-950">
      {children}
    </div>
  );
}

### ./src/app/(auth)/login/page.tsx
"use client";

import { useState, FormEvent } from 'react';
import { useRouter } from 'next/navigation';
import { useAppDispatch, useAppSelector } from '../../../store/hooks';
import { loginUser, registerUser } from '../../../store/slices/authSlice';
import { Button } from '../../../components/ui/Button';
import { Input } from '../../../components/ui/Input';
import { Card } from '../../../components/ui/Card';

export default function LoginPage() {
  const [isLogin, setIsLogin] = useState(true);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');

  const dispatch = useAppDispatch();
  const router = useRouter();
  const status = useAppSelector((state) => state.auth.status);
  const authError = useAppSelector((state) => state.auth.error);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError('');

    if (!isLogin && password !== confirmPassword) {
      setError('Пароли не совпадают');
      return;
    }

    try {
      if (isLogin) {
        await dispatch(loginUser({ email, password })).unwrap();
        router.push('/dashboard');
      } else {
        await dispatch(registerUser({ email, password })).unwrap();
        // После успешной регистрации выполняем вход
        await dispatch(loginUser({ email, password })).unwrap();
        router.push('/dashboard');
      }
    } catch (err) {
      setError(authError || 'Произошла ошибка');
    }
  };

  return (
    <Card className="w-full max-w-md mx-4">
      <h1 className="text-2xl font-bold text-center mb-6">
        {isLogin ? 'Вход' : 'Регистрация'}
      </h1>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Email
          </label>
          <Input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Пароль
          </label>
          <Input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        {!isLogin && (
          <div>
            <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Подтвердите пароль
            </label>
            <Input
              id="confirmPassword"
              type="password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              required
            />
          </div>
        )}
        {error && (
          <p className="text-red-500 text-sm">{error}</p>
        )}
        <Button
          type="submit"
          className="w-full"
          disabled={status === 'loading'}
        >
          {status === 'loading'
            ? 'Загрузка...'
            : isLogin
              ? 'Войти'
              : 'Зарегистрироваться'
          }
        </Button>
      </form>
      <div className="mt-4 text-center">
        <button
          type="button"
          onClick={() => {
            setIsLogin(!isLogin);
            setError('');
          }}
          className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300"
        >
          {isLogin
            ? 'Нет аккаунта? Зарегистрируйтесь'
            : 'Уже есть аккаунт? Войдите'
          }
        </button>
      </div>
    </Card>
  );
}


### ./src/app/(main)/layout.tsx
"use client";

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useAppDispatch, useAppSelector } from '@/store/hooks';
import { fetchUserProfile } from '@/store/slices/userSlice';

export default function MainLayout({ children }: { children: React.ReactNode }) {
  const router = useRouter();
  const dispatch = useAppDispatch();
  const { isAuthenticated, token } = useAppSelector((state) => state.auth);
  const userStatus = useAppSelector((state) => state.user.status);


  useEffect(() => {
    if (token) {
      if (userStatus === 'idle') {
        dispatch(fetchUserProfile());
      }
    } else {
      router.push('/login');
    }
  }, [token, isAuthenticated, userStatus, dispatch, router]);
  
  if (!isAuthenticated) {
    return (
        <div className="flex items-center justify-center min-h-screen">
            <p>Загрузка...</p>
        </div>
    );
  }

  return (
    <div className="flex flex-col min-h-screen bg-gray-50 dark:bg-gray-950">
      <main className="flex-grow container mx-auto px-6 py-8">
        {children}
      </main>
    </div>
  );
}


### ./src/app/(main)/create/page.tsx
"use client";

import { useEffect, useState, DragEvent, ChangeEvent } from 'react';
import { useRouter } from 'next/navigation';
import { api } from '../../../lib/api';
import { useAppDispatch, useAppSelector } from '../../../store/hooks';
import { createAndGenerateProject } from '../../../store/slices/projectsSlice';
import { Button } from '../../../components/ui/Button';
import { Card } from '../../../components/ui/Card';
import { Input } from '../../../components/ui/Input';
import { Textarea } from '../../../components/ui/Textarea';

// Типы
interface Style { id: string; name: string; slug: string; }
interface FurnitureItem { id: string; name: string; category: 'furniture' | 'decor'; icon: string; }

const FileIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
    </svg>
);

export default function CreatePage() {
    const router = useRouter();
    const dispatch = useAppDispatch();
    const { status: generationStatus, error: generationError } = useAppSelector(state => state.projects);

    // Локальное состояние для справочников
    const [styles, setStyles] = useState<Style[]>([]);
    const [furniture, setFurniture] = useState<FurnitureItem[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    // Локальное состояние формы
    const [projectName, setProjectName] = useState('');
    const [prompt, setPrompt] = useState('');
    const [originalImage, setOriginalImage] = useState<File | null>(null);
    const [referenceImages, setReferenceImages] = useState<File[]>([]);
    const [originalImagePreview, setOriginalImagePreview] = useState<string | null>(null);
    const [referenceImagePreviews, setReferenceImagePreviews] = useState<string[]>([]);
    const [selectedStyleId, setSelectedStyleId] = useState<string | null>(null);
    const [selectedFurniture, setSelectedFurniture] = useState<Record<string, boolean>>({});
    const [isDragging, setIsDragging] = useState(false);
    const [errors, setErrors] = useState<{ [key: string]: string | undefined }>({});

    useEffect(() => {
        const fetchData = async () => {
            setIsLoading(true);
            try {
                const [stylesRes, furnitureRes] = await Promise.all([api.get('/styles'), api.get('/furniture')]);
                setStyles(stylesRes.data);
                setFurniture(furnitureRes.data);
            } catch (error) {
                setErrors({ general: "Не удалось загрузить данные для создания проекта." });
            } finally {
                setIsLoading(false);
            }
        };
        fetchData();
    }, []);

    const validateForm = () => {
        const newErrors: { [key: string]: string | undefined } = {};
        if (!projectName.trim()) newErrors.projectName = "Введите название проекта.";
        if (!originalImage) newErrors.originalImage = "Загрузите основное изображение.";
        if (!selectedStyleId) newErrors.style = "Выберите стиль.";
        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
    };

    const handleGenerate = async () => {
        if (!validateForm()) return;

        const checklist = Object.keys(selectedFurniture).filter(key => selectedFurniture[key]).map(itemId => ({ itemId }));
        
        dispatch(createAndGenerateProject({
            projectName,
            prompt: prompt.trim(),
            originalImage: originalImage!,
            referenceImages,
            selectedStyleId: selectedStyleId!,
            checklist,
        })).unwrap()
        .then(() => {
            alert("Задача на генерацию успешно создана! Вы будете перенаправлены на страницу проектов.");
            router.push('/dashboard');
        })
        .catch((error) => {
            setErrors({ general: error || "Произошла неизвестная ошибка." });
        });
    };
    
    // --- Остальные хендлеры (без изменений) ---
    const handleOriginalImageSelect = (file: File | undefined) => { if (file && file.type.startsWith('image/')) { setOriginalImage(file); if (originalImagePreview) URL.revokeObjectURL(originalImagePreview); setOriginalImagePreview(URL.createObjectURL(file)); setErrors(p => ({ ...p, originalImage: undefined })); } };
    const handleReferenceImagesSelect = (files: FileList | null) => { if (files) { const newFiles = Array.from(files); if (referenceImages.length + newFiles.length > 3) { alert("Максимум 3 референса."); return; } setReferenceImages(p => [...p, ...newFiles]); setReferenceImagePreviews(p => [...p, ...newFiles.map(URL.createObjectURL)]); } };
    const removeReferenceImage = (index: number) => { URL.revokeObjectURL(referenceImagePreviews[index]); setReferenceImages(p => p.filter((_, i) => i !== index)); setReferenceImagePreviews(p => p.filter((_, i) => i !== index)); };
    const handleDragEvents = (e: DragEvent<HTMLDivElement>, d: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(d); };
    const handleDrop = (e: DragEvent<HTMLDivElement>) => { handleDragEvents(e, false); handleOriginalImageSelect(e.dataTransfer.files?.[0]); };

    if (isLoading) return <p className="text-center mt-10">Загрузка...</p>;

    return (
        <div className="space-y-6 max-w-4xl mx-auto">
            <h1 className="text-3xl font-bold">Создать новый дизайн</h1>
            {errors.general && <div className="p-3 bg-red-100 text-red-800 rounded-md">{errors.general}</div>}
            {generationError && !errors.general && <div className="p-3 bg-red-100 text-red-800 rounded-md">{generationError}</div>}

            <Card>
                <h2 className="text-xl font-bold mb-4">1. Опишите проект</h2>
                <div className="space-y-4">
                    <div>
                        <label htmlFor="projectName" className="block text-sm font-medium mb-1">Название проекта</label>
                        <Input id="projectName" value={projectName} onChange={e => setProjectName(e.target.value)} />
                        {errors.projectName && <p className="text-red-500 text-sm mt-1">{errors.projectName}</p>}
                    </div>
                    <div>
                        <label htmlFor="prompt" className="block text-sm font-medium mb-1">Ваши пожелания (промпт)</label>
                        <Textarea id="prompt" value={prompt} onChange={e => setPrompt(e.target.value)} rows={3}/>
                    </div>
                </div>
            </Card>

            <Card>
                 <h2 className="text-xl font-bold mb-4">2. Загрузите изображения</h2>
                 <div className="grid md:grid-cols-2 gap-6">
                    <div>
                        <label className="block text-sm font-medium mb-2">Основное изображение *</label>
                         <input type="file" id="original-image-upload" className="hidden" onChange={(e) => handleOriginalImageSelect(e.target.files?.[0])} accept="image/*" />
                         {originalImagePreview ? (
                             <div className="relative"><img src={originalImagePreview} alt="Превью" className="w-full h-auto max-h-80 object-contain rounded-md border" /><Button variant="danger" size="sm" onClick={() => { setOriginalImage(null); setOriginalImagePreview(null); }} className="absolute top-2 right-2">Удалить</Button></div>
                         ) : (
                             <div onClick={() => document.getElementById('original-image-upload')?.click()} onDragEnter={(e) => handleDragEvents(e, true)} onDragLeave={(e) => handleDragEvents(e, false)} onDragOver={(e) => e.preventDefault()} onDrop={handleDrop} className={`flex flex-col items-center justify-center p-8 border-2 border-dashed rounded-md cursor-pointer transition-colors ${isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-gray-400'}`}><FileIcon /><p className="mt-2 text-sm text-gray-500"><span className="font-semibold text-blue-600">Нажмите</span> или перетащите</p></div>
                         )}
                         {errors.originalImage && <p className="text-red-500 text-sm mt-1">{errors.originalImage}</p>}
                    </div>
                    <div>
                        <label className="block text-sm font-medium mb-2">Изображения-референсы (до 3)</label>
                        <input type="file" id="reference-upload" multiple className="hidden" onChange={(e) => handleReferenceImagesSelect(e.target.files)} accept="image/*" />
                        <div className="grid grid-cols-3 gap-2">
                            {referenceImagePreviews.map((p, i) => <div key={i} className="relative"><img src={p} className="w-full h-24 object-cover rounded-md" /><button onClick={() => removeReferenceImage(i)} className="absolute top-1 right-1 bg-red-600 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs">&times;</button></div>)}
                            {referenceImages.length < 3 && <div onClick={() => document.getElementById('reference-upload')?.click()} className="flex items-center justify-center h-24 border-2 border-dashed rounded-md cursor-pointer hover:border-gray-400"><span className="text-2xl text-gray-400">+</span></div>}
                        </div>
                    </div>
                 </div>
            </Card>

            <Card>
                <h2 className="text-xl font-bold mb-4">3. Выберите стиль *</h2>
                 <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    {styles.map(style => <button key={style.id} onClick={() => { setSelectedStyleId(style.id); setErrors(p => ({...p, style: undefined})); }} className={`p-4 border rounded-lg text-left transition-all ${selectedStyleId === style.id ? 'border-blue-500 bg-blue-50 ring-2 ring-blue-500' : 'hover:bg-gray-50'}`}><p className="font-bold text-lg">{style.name}</p></button>)}
                </div>
                {errors.style && <p className="text-red-500 text-sm mt-2">{errors.style}</p>}
            </Card>
            
            <Card>
                <h2 className="text-xl font-bold mb-4">4. Выберите мебель и декор</h2>
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    {furniture.map(item => <label key={item.id} className="flex items-center space-x-2 p-3 border rounded-md cursor-pointer hover:bg-gray-50"><Input type="checkbox" className="h-4 w-4" checked={!!selectedFurniture[item.id]} onChange={() => setSelectedFurniture(p => ({...p, [item.id]: !p[item.id]}))} /><span>{item.name}</span></label>)}
                </div>
            </Card>
            
            <div className="flex justify-end pt-4">
                 <Button onClick={handleGenerate} disabled={generationStatus === 'loading'} size="lg">
                    {generationStatus === 'loading' ? 'Создание...' : 'Создать дизайн'}
                </Button>
            </div>
        </div>
    );
}


### ./src/app/(main)/dashboard/page.tsx
"use client";

import { useEffect, useRef } from 'react';
import Link from 'next/link';
import { useAppDispatch, useAppSelector } from '../../../store/hooks';
import { fetchProjects, deleteProject } from '../../../store/slices/projectsSlice';
import { Button } from '../../../components/ui/Button';
import { Card } from '../../../components/ui/Card';

interface Project {
  id: string;
  name: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  originalImageUrl: string;
  generatedImageUrl: string | null;
  style: { name: string };
}

const StatusBadge = ({ status }: { status: Project['status'] }) => {
  const styles = {
    pending: 'bg-gray-200 text-gray-800',
    processing: 'bg-blue-200 text-blue-800 animate-pulse',
    completed: 'bg-green-200 text-green-800',
    failed: 'bg-red-200 text-red-800',
  };
  const text = { pending: 'Ожидание', processing: 'В обработке', completed: 'Готово', failed: 'Ошибка' };
  return <span className={`px-2 py-1 text-xs font-semibold rounded-full ${styles[status]}`}>{text[status]}</span>;
};

export default function DashboardPage() {
  const dispatch = useAppDispatch();
  const { items: projects, status } = useAppSelector((state) => state.projects);
  const pollingInterval = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchProjects());
    }
    
    const isProcessing = projects.some(p => ['pending', 'processing'].includes(p.status));
    
    if (isProcessing && !pollingInterval.current) {
      pollingInterval.current = setInterval(() => dispatch(fetchProjects()), 5000);
    } else if (!isProcessing && pollingInterval.current) {
      clearInterval(pollingInterval.current);
      pollingInterval.current = null;
    }

    return () => { if (pollingInterval.current) clearInterval(pollingInterval.current); };
  }, [status, dispatch, projects]);

  const handleDelete = (id: string) => {
    if (window.confirm("Удалить проект?")) dispatch(deleteProject(id));
  };

  if (status === 'loading' && projects.length === 0) return <p className="text-center mt-10">Загрузка проектов...</p>;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Мои проекты</h1>
        <Link href="/create"><Button>Создать новый</Button></Link>
      </div>

      {projects.length === 0 ? (
        <Card className="text-center py-10"><p className="text-gray-500">У вас пока нет проектов.</p></Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {projects.map((project) => (
            <Card key={project.id} className="flex flex-col">
              <div className="flex justify-between items-start mb-2">
                <h3 className="font-bold text-lg leading-tight">{project.name}</h3>
                <StatusBadge status={project.status} />
              </div>
<p className="text-sm text-gray-500 mb-4">Стиль: {project.style?.name || '...'}</p>
              
              <div className="flex-grow grid grid-cols-2 gap-4 mb-4">
                <div className="text-center">
                  <img src={project.originalImageUrl} alt="Original" className="w-full h-32 object-cover rounded-md bg-gray-200" />
                  <p className="text-xs mt-1 text-gray-500">Оригинал</p>
                </div>
                <div className="text-center">
                  {project.generatedImageUrl ? 
                    <img src={project.generatedImageUrl} alt="Generated" className="w-full h-32 object-cover rounded-md bg-gray-200" /> : 
                    <div className="w-full h-32 flex items-center justify-center bg-gray-200 rounded-md text-gray-400 text-3xl">?</div>}
                  <p className="text-xs mt-1 text-gray-500">Результат</p>
                </div>
              </div>

              <Button onClick={() => handleDelete(project.id)} variant="danger" size="sm" className="w-full mt-auto">Удалить</Button>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}


### ./src/app/(main)/profile/page.tsx
"use client";

import { useState, FormEvent, useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '@/store/hooks';
import { updateUserProfile, deleteUserAccount } from '@/store/slices/userSlice';
import { Button } from '@/components/ui/Button';
import { Input } from '@/components/ui/Input';
import { Card } from '@/components/ui/Card';

export default function ProfilePage() {
  const dispatch = useAppDispatch();
  const { profile, status, error } = useAppSelector((state) => state.user);

  const [name, setName] = useState(profile?.name || '');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [deleteConfirm, setDeleteConfirm] = useState('');
  
  const [notification, setNotification] = useState<{type: 'success' | 'error', message: string} | null>(null);

  useEffect(() => {
    if (profile) {
      setName(profile.name || '');
    }
  }, [profile]);

  const handleUpdate = async (e: FormEvent) => {
    e.preventDefault();
    setNotification(null);
    const updateData: { name?: string; password?: string } = {};

    if (name !== profile?.name) {
      updateData.name = name;
    }
    if (password) {
      if (password !== confirmPassword) {
        setNotification({type: 'error', message: 'Пароли не совпадают'});
        return;
      }
      updateData.password = password;
    }

    if (Object.keys(updateData).length > 0) {
      const result = await dispatch(updateUserProfile(updateData));
      if (updateUserProfile.fulfilled.match(result)) {
        setNotification({type: 'success', message: 'Профиль успешно обновлен!'});
        setPassword('');
        setConfirmPassword('');
      } else {
        setNotification({type: 'error', message: (result.payload as string) || 'Ошибка обновления'});
      }
    }
  };

  const handleDelete = async () => {
      setNotification(null);
      if (deleteConfirm.toLowerCase() !== 'удалить') {
          setNotification({type: 'error', message: 'Введите "удалить" для подтверждения.'});
          return;
      }
      if (window.confirm('Вы абсолютно уверены? Это действие необратимо.')) {
          dispatch(deleteUserAccount());
      }
  }

  if (!profile) return <p>Загрузка профиля...</p>;

  return (
    <div className="max-w-4xl mx-auto grid gap-8 md:grid-cols-2">
      <Card>
        <h2 className="text-2xl font-bold mb-4">Личные данные</h2>
        
        {notification && (
            <div className={`p-3 mb-4 rounded-md text-sm ${
                notification.type === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
            }`}>
            {notification.message}
            </div>
        )}

        <form onSubmit={handleUpdate} className="space-y-4">
          <div>
            <label htmlFor="email">Email (нельзя изменить)</label>
            <Input id="email" type="email" value={profile.email} disabled />
          </div>
          <div>
            <label htmlFor="name">Имя</label>
            <Input id="name" type="text" value={name} onChange={(e) => setName(e.target.value)} />
          </div>
          <div>
            <label htmlFor="password">Новый пароль</label>
            <Input id="password" type="password" value={password} onChange={(e) => setPassword(e.target.value)} placeholder="Оставьте пустым, если не хотите менять"/>
          </div>
          <div>
            <label htmlFor="confirmPassword">Повторите новый пароль</label>
            <Input id="confirmPassword" type="password" value={confirmPassword} onChange={(e) => setConfirmPassword(e.target.value)} />
          </div>
          <Button type="submit" disabled={status === 'loading'}>
            {status === 'loading' ? 'Сохранение...' : 'Сохранить изменения'}
          </Button>
        </form>
      </Card>

      <Card>
        <h2 className="text-2xl font-bold mb-4 text-red-600">Опасная зона</h2>
        <p className="mb-4">Удаление аккаунта приведет к безвозвратному удалению всех ваших данных и проектов.</p>
        <div>
          <label htmlFor="deleteConfirm">Для подтверждения введите "удалить"</label>
          <Input 
            id="deleteConfirm" 
            type="text"
            value={deleteConfirm}
            onChange={(e) => setDeleteConfirm(e.target.value)}
            className="border-red-500 focus:ring-red-500"
          />
        </div>
        <Button onClick={handleDelete} variant="danger" className="mt-4 w-full" disabled={status === 'loading'}>
          Удалить аккаунт
        </Button>
      </Card>
    </div>
  );
}

### ./src/components/Header.tsx
"use client";

import Link from 'next/link';
import Image from 'next/image';
import { useAppSelector } from '@/store/hooks'; // useDispatch and other imports might not be needed here anymore
import { usePathname } from 'next/navigation';

export function Header() {
  const isAuthenticated = useAppSelector((state) => state.auth.isAuthenticated);
  const pathname = usePathname();
  // Логика выхода (handleLogout) теперь должна быть на странице профиля, а не в хедере,
  // чтобы соответствовать минималистичному дизайну.

  return (
    <header className="bg-[#EBEAE8] sticky top-0 z-10 w-full py-4">
      <div className="container mx-auto px-6 flex flex-col items-center">
        
        {/* Верхняя строка: Логотип */}
        <div className="mb-5"> {/* Отступ снизу для разделения с навигацией */}
          <Link href="/">
            {/* Убедитесь, что у вас есть logo.svg в папке public */}
            <Image 
              src="/logo.png" 
              alt="Образно Лого" 
              width={180} // Немного увеличим для акцента
              height={45} 
              priority // Помогает загрузить логотип быстрее
            />
          </Link>
        </div>

        {/* Нижняя строка: Навигация */}
        <nav className="flex justify-center items-center space-x-12 text-sm font-medium tracking-wider text-[24px]">
          <Link 
            href="/" 
            className={`${pathname === '/' ? 'text-[#F14D34]' : 'text-gray-700'} hover:text-black transition-colors`}
          >
            о нас
          </Link>
          <Link href="/contacts" className="text-gray-700 hover:text-black transition-colors">
            контакты
          </Link>
          <Link href="/obrazno-ai" className="text-gray-700 hover:text-red-600 transition-colors">
            образно AI
          </Link>
          
          {/* Иконка профиля/входа */}
          <Link href={isAuthenticated ? "/profile" : "/login"}>
              {/* Убедитесь, что у вас есть profile.svg в папке public */}
              <Image 
                src="/profile.svg" 
                alt="Профиль" 
                width={28} 
                height={28} 
              />
          </Link>
        </nav>
      </div>
    </header>
  );
}


### ./src/components/main/About_main.ts


### ./src/components/ui/Button.tsx
import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
}

export function Button({ children, variant = 'primary', size = 'md', className, ...props }: ButtonProps) {
  const baseClasses = 'rounded-md font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transition-colors inline-flex items-center justify-center';
  
  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300 focus:ring-gray-400',
    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
  };

  const sizeClasses = {
      lg: 'px-8 py-3 text-lg',
      md: 'px-4 py-2 text-sm',
      sm: 'px-2 py-1 text-xs',
  }

  return (
    <button className={`${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${className}`} {...props}>
      {children}
    </button>
  );
}


### ./src/components/ui/Card.tsx
import React from 'react';

interface CardProps {
  children: React.ReactNode;
  className?: string;
}

export function Card({ children, className }: CardProps) {
  return (
    <div className={`bg-white dark:bg-gray-800 shadow-md rounded-lg p-6 ${className}`}>
      {children}
    </div>
  );
}


### ./src/components/ui/Input.tsx
import React from 'react';

export const Input = React.forwardRef<HTMLInputElement, React.InputHTMLAttributes<HTMLInputElement>>(
  ({ className, ...props }, ref) => {
    return (
      <input
        className={`w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white ${className}`}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = 'Input';


### ./src/components/ui/Textarea.tsx
import React from 'react';

export const Textarea = React.forwardRef<HTMLTextAreaElement, React.TextareaHTMLAttributes<HTMLTextAreaElement>>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={`w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white ${className}`}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = 'Textarea';


### ./src/lib/api.ts
import axios from 'axios';

export const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
});

// Создаем перехватчик (interceptor) для всех исходящих запросов
api.interceptors.request.use(
  (config) => {
    // Перед каждым запросом получаем токен из localStorage
    const token = localStorage.getItem('token');
    // Если токен есть, добавляем его в заголовок Authorization
    if (token) {
      config.headers.Authorization = `Bearer ${token}`; // Стандартный формат 'Bearer <token>'
    }
    return config;
  },
  (error) => Promise.reject(error)
);


### ./src/store/AuthInitializer.tsx
"use client";

import { useEffect, useState } from 'react';
import { useAppDispatch } from './hooks';
import { loadToken } from './slices/authSlice';

/**
 * Этот компонент-обертка гарантирует, что состояние аутентификации
 * будет инициализировано из localStorage ДО того, как остальная часть
 * приложения будет отрендерена на клиенте. Это предотвращает "мигание"
 * страницы входа для уже залогиненных пользователей.
 */
export function AuthInitializer({ children }: { children: React.ReactNode }) {
  const dispatch = useAppDispatch();
  const [isInitializing, setIsInitializing] = useState(true);

  useEffect(() => {
    // Синхронно диспатчим действие для загрузки токена
    dispatch(loadToken());
    // Сразу после диспатча говорим, что инициализация завершена
    setIsInitializing(false);
  }, [dispatch]);

  // Пока идет инициализация, ничего не рендерим (или показываем глобальный спиннер)
  if (isInitializing) {
    return null;
  }

  return <>{children}</>;
}


### ./src/store/hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;


### ./src/store/Provider.tsx
"use client";

import { Provider } from 'react-redux';
import { store } from './store';
import { AuthInitializer } from './AuthInitializer';

export function ReduxProvider({ children }: { children: React.ReactNode }) {
  return (
    <Provider store={store}>
      <AuthInitializer>{children}</AuthInitializer>
    </Provider>
  );
}


### ./src/store/store.ts
import { configureStore } from '@reduxjs/toolkit';
import authReducer from './slices/authSlice';
import userReducer from './slices/userSlice';
import projectsReducer from './slices/projectsSlice';

export const store = configureStore({
  reducer: {
    auth: authReducer,
    user: userReducer,
    projects: projectsReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;


### ./src/store/slices/authSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { api } from '../../lib/api';
import { fetchUserProfile } from './userSlice';

interface AuthState {
  token: string | null;
  isAuthenticated: boolean;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: AuthState = {
  token: null,
  isAuthenticated: false,
  status: 'idle',
  error: null,
};

// Async Thunks
export const loginUser = createAsyncThunk('auth/login', async (credentials: any, { dispatch, rejectWithValue }) => {
  try {
    const response = await api.post('/auth/login', credentials);
    const { access_token } = response.data;
    localStorage.setItem('token', access_token);
    await dispatch(fetchUserProfile());
    return access_token;
  } catch (error: any) {
    return rejectWithValue(error.response?.data?.message || 'Login failed');
  }
});

export const registerUser = createAsyncThunk('auth/register', async (credentials: any, { rejectWithValue }) => {
  try {
    await api.post('/auth/register', credentials);
  } catch (error: any) {
    return rejectWithValue(error.response?.data?.message || 'Registration failed');
  }
});

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    loadToken(state) {
      const token = localStorage.getItem('token');
      if (token) {
        state.token = token;
        state.isAuthenticated = true;
      }
    },
    logout(state) {
      state.token = null;
      state.isAuthenticated = false;
      localStorage.removeItem('token');
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(loginUser.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action: PayloadAction<string>) => {
        state.status = 'succeeded';
        state.token = action.payload;
        state.isAuthenticated = true;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      })
      .addCase(registerUser.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(registerUser.fulfilled, (state) => {
        state.status = 'succeeded';
      })
      .addCase(registerUser.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      });
  },
});

export const { loadToken, logout } = authSlice.actions;
export default authSlice.reducer;


### ./src/store/slices/projectsSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { api } from '../../lib/api';

// --- Типы ---
interface Project {
  id: string;
  name: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  originalImageUrl: string;
  generatedImageUrl: string | null;
  style: {
    id: string;
    name: string;
    slug: string;
  };
}

interface ProjectsState {
  items: Project[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: ProjectsState = {
  items: [],
  status: 'idle',
  error: null,
};

// --- Async Thunks ---
export const fetchProjects = createAsyncThunk('projects/fetchProjects', async (_, { rejectWithValue }) => {
  try {
    const response = await api.get('/projects');
    return response.data;
  } catch (error: any) {
    return rejectWithValue(error.response?.data?.message || 'Не удалось загрузить проекты');
  }
});

export const deleteProject = createAsyncThunk('projects/deleteProject', async (projectId: string, { rejectWithValue }) => {
  try {
    await api.delete(`/projects/${projectId}`);
    return projectId;
  } catch (error: any) {
    return rejectWithValue(error.response?.data?.message || 'Не удалось удалить проект');
  }
});

interface CreateProjectPayload {
    projectName: string;
    prompt: string;
    originalImage: File;
    referenceImages: File[];
    selectedStyleId: string;
    checklist: { itemId: string }[];
}

export const createAndGenerateProject = createAsyncThunk(
    'projects/createAndGenerate', 
    async (payload: CreateProjectPayload, { dispatch, rejectWithValue }) => {
        try {
            const { projectName, prompt, originalImage, referenceImages, selectedStyleId, checklist } = payload;
            
            const uploadFormData = new FormData();
            uploadFormData.append('originalImage', originalImage);
            referenceImages.forEach(file => uploadFormData.append('referenceImages', file));
            const uploadRes = await api.post('/uploads/project-images', uploadFormData);
            const { originalImageUrl, referenceImageUrls } = uploadRes.data;

            const projectRes = await api.post('/projects', {
                name: projectName,
                styleId: selectedStyleId,
                originalImageUrl,
                referenceImageUrls,
            });
            const { id: projectId } = projectRes.data;

            await api.post('/generate', { projectId, prompt, checklist });
            
            // --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ---
            // Вместо возврата данных, запускаем полное обновление списка.
            dispatch(fetchProjects());

        } catch (error: any) {
            return rejectWithValue(error.response?.data?.message || 'Ошибка при создании проекта');
        }
    }
);

const projectsSlice = createSlice({
  name: 'projects',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Fetch Projects
      .addCase(fetchProjects.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchProjects.fulfilled, (state, action: PayloadAction<Project[]>) => {
        state.status = 'succeeded';
        state.items = action.payload; // Теперь список обновляется здесь
      })
      .addCase(fetchProjects.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      })
      // Delete Project
      .addCase(deleteProject.fulfilled, (state, action: PayloadAction<string>) => {
        state.items = state.items.filter((item) => item.id !== action.payload);
      })
      // Create and Generate Project
      .addCase(createAndGenerateProject.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(createAndGenerateProject.fulfilled, (state) => {
        // --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ---
        // Больше не добавляем проект вручную.
        // Статус перейдет в 'loading' из-за вызова fetchProjects, что является корректным поведением.
        state.status = 'succeeded';
      })
      .addCase(createAndGenerateProject.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      });
  },
});

export default projectsSlice.reducer;


### ./src/store/slices/userSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { api } from '../../lib/api';
import { logout } from './authSlice';

interface User {
  id: string;
  email: string;
  name: string | null;
}

interface UserState {
  profile: User | null;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: UserState = {
  profile: null,
  status: 'idle',
  error: null,
};

// Async Thunks
export const fetchUserProfile = createAsyncThunk('user/fetchProfile', async (_, { rejectWithValue }) => {
  try {
    const response = await api.get('/users/me');
    return response.data;
  } catch (error: any) {
    return rejectWithValue(error.response?.data?.message || 'Failed to fetch profile');
  }
});

export const updateUserProfile = createAsyncThunk('user/updateProfile', async (data: any, { rejectWithValue }) => {
  try {
    const response = await api.put('/users/me', data);
    return response.data;
  } catch (error: any) {
    return rejectWithValue(error.response?.data?.message || 'Failed to update profile');
  }
});

export const deleteUserAccount = createAsyncThunk('user/deleteAccount', async (_, { dispatch, rejectWithValue }) => {
  try {
    await api.delete('/users/me');
    dispatch(logout());
  } catch (error: any) {
    return rejectWithValue(error.response?.data?.message || 'Failed to delete account');
  }
});

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    clearProfile(state) {
      state.profile = null;
      state.status = 'idle';
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // Logout clears profile
      .addCase(logout, (state) => {
        state.profile = null;
      })
      // Fetch profile
      .addCase(fetchUserProfile.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchUserProfile.fulfilled, (state, action: PayloadAction<User>) => {
        state.status = 'succeeded';
        state.profile = action.payload;
      })
      .addCase(fetchUserProfile.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      })
      // Update profile
      .addCase(updateUserProfile.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(updateUserProfile.fulfilled, (state, action: PayloadAction<User>) => {
        state.status = 'succeeded';
        state.profile = action.payload;
      })
      .addCase(updateUserProfile.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      })
      // Delete account
      .addCase(deleteUserAccount.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(deleteUserAccount.fulfilled, (state) => {
        state.status = 'succeeded';
        state.profile = null;
      })
      .addCase(deleteUserAccount.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      });
  },
});

export const { clearProfile } = userSlice.actions;
export default userSlice.reducer;


